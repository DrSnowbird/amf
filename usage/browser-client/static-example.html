<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ScalaJS</title>
</head>
<body>
<!-- Include Scala.js compiled code -->
<script type="text/javascript" src="../../amf-js/target/artifact/amf-browser.js"></script>


<label>From:</label><select id="from">
    <option value="raml">Raml</option>
    <option value="oas">Oas</option>
    <option value="amf">Amf</option>
</select>

<label>To:</label><select id="to">
    <option value="raml" selected>Raml</option>
    <option value="oas">Oas</option>
    <option value="amf">Amf</option>
</select>

<label>Api:</label><textarea id="api"> </textarea>

<label>WebApi Description:</label><textarea id="webApiDescription"> </textarea>

<label>Muted WebApi Dumped:</label><textarea id="changedWebApi"></textarea>

</label>

<button id="click">Try Me!</button>

<script>
    /** Aux method to choose and create the right parser*/
    function getParser() {
        var from = document.getElementById("from").value
        if (from === "raml") return new RamlParser()
        if (from === "oas") return new OasParser()
        return new AmfParser()
    }

    /** Aux method to choose and create the right generator*/
    function getGenerator() {
        var to = document.getElementById("to").value
        if (to === "raml") return new RamlGenerator()
        if (to === "oas") return new OasGenerator()
        return new AmfGenerator()
    }

    /**Shows how change fields of the web api. Also, you can add new fields in any label, like operations, endpoints, parameters etc.
     * For example: doc.encodes.endPoint.withOperation( "new operation method")
     * */
    function mutateApi(doc) {
        doc.encodes.withName("new name").withDescription("new description");
        return doc
    }

    document.getElementById("click").addEventListener("click", click);

    function click() {
        console.log("Clicked!");
        const parser = getParser()

        const api = document.getElementById("api").value;
        alert("parser: "+parser)
        /**
         * Call the parseString amf method. Pass a handler to with logic to be executed after the parse be complete.
         * If you have a file instead of a string, you can call parser.parseFile(path, handler).
         * Also, you can call parser.parseStringAsync(api) that will return a promise of document.
         */
        parser.parseString(api,
            {
                success: function (doc) {
                    /** Barely mutate the api. You can do mayor changes if you want to play */
                    document.getElementById("webApiDescription").value = doc.encodes.description

                    /**
                     * Call the generateString amf method. Pass a handler to with logic to be executed after the generation be complete.
                     * If you want to dump to a file instead of a string, you can call generator.generateFile(path, handler).
                     * Also, you can call generator.generateStringAsync(api) that will return a promise of the string api.
                     */
                    getGenerator().generateString(mutateApi(doc), {
                        success: function (doc) {
                            document.getElementById("changedWebApi").value = doc
                        },
                        error: function (exception) {
                            console.log('Error', exception);
                        }
                    })
                },
                error: function (exception) {
                    console.log('Error', exception);
                }
            })

    }
</script>

<p id="result"></p>
</body>
</html>